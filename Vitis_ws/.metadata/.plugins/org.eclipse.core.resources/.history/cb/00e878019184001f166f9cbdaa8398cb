#include "xuartps.h"
#include "xparameters.h"

XUartPs UartPs;

int SetupUart(void){

	XUartPs_Config *Config;
	int Status;

    Config = XUartPs_LookupConfig(XPAR_XUARTPS_1_DEVICE_ID);

    if (NULL == Config) {
            return XST_FAILURE;
    }

    // Initialize the UART driver
    Status = XUartPs_CfgInitialize(&UartPs, Config, Config->BaseAddress);
    if (Status != XST_SUCCESS) {
        return XST_FAILURE;
    }

    // Set UART in normal mode
    XUartPs_SetOperMode(&UartPs, XUARTPS_OPER_MODE_NORMAL);

    // Set baud rate (31250 for standard MIDI)
    XUartPs_SetBaudRate(&UartPs, 31250);

    return XST_SUCCESS;
}

void SetupUartInterrupts(void)
{
    // Enable UART interrupts
    XUartPs_SetInterruptMask(&UartPs, XUARTPS_IXR_RXOVR | XUARTPS_IXR_RXFULL);

    // Set up the interrupt system
    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
                                 (Xil_ExceptionHandler)XScuGic_InterruptHandler,
                                 &IntcInstance);
    Xil_ExceptionEnable();

    // Connect the UART interrupt to the GIC
    XScuGic_Connect(&IntcInstance, XPAR_XUARTPS_1_INTR,
                    (Xil_InterruptHandler)UartInterruptHandler,
                    (void *)&UartPs);

    // Enable the UART interrupt at the GIC
    XScuGic_Enable(&IntcInstance, XPAR_XUARTPS_1_INTR);
}

void UartInterruptHandler(void *CallBackRef)
{
    u32 IsrStatus;
    XUartPs *UartInstancePtr = (XUartPs *)CallBackRef;

    // Read the interrupt status register
    IsrStatus = XUartPs_ReadReg(UartInstancePtr->Config.BaseAddress, XUARTPS_ISR_OFFSET);

    // Check for received data interrupt
    if (IsrStatus & XUARTPS_IXR_RXFULL) {
        // Read the data and store it in the buffer
        while (XUartPs_IsReceiveData(UartInstancePtr->Config.BaseAddress)) {
            u8 ReceivedByte = XUartPs_ReadReg(UartInstancePtr->Config.BaseAddress, XUARTPS_FIFO_OFFSET);
            StoreByteInBuffer(ReceivedByte);
        }
    }

    // Clear the interrupt status register
    XUartPs_WriteReg(UartInstancePtr->Config.BaseAddress, XUARTPS_ISR_OFFSET, IsrStatus);
}

#define BUFFER_SIZE 256

typedef struct {
    u8 data[BUFFER_SIZE];
    int head;
    int tail;
} CircularBuffer;

CircularBuffer midiBuffer;

void InitializeBuffer(CircularBuffer* buffer) {
    buffer->head = 0;
    buffer->tail = 0;
}

void StoreByteInBuffer(u8 byte) {
    int next = (midiBuffer.head + 1) % BUFFER_SIZE;
    if (next != midiBuffer.tail) {
        midiBuffer.data[midiBuffer.head] = byte;
        midiBuffer.head = next;
    }
    // Note: If buffer is full, the new byte is discarded
}

int ReadByteFromBuffer(u8* byte) {
    if (midiBuffer.head == midiBuffer.tail) {
        return 0;  // Buffer is empty
    }
    *byte = midiBuffer.data[midiBuffer.tail];
    midiBuffer.tail = (midiBuffer.tail + 1) % BUFFER_SIZE;
    return 1;  // Byte read successfully
}

void ParseUartMessages(void)
{
    u8 status, data1, data2;

    while (ReadByteFromBuffer(&status)) {
        if (status & 0x80) {  // This is a status byte
            switch (status & 0xF0) {
                case 0x80:  // Note Off
                case 0x90:  // Note On
                case 0xB0:  // Control Change
                    if (ReadByteFromBuffer(&data1) && ReadByteFromBuffer(&data2)) {
                        ProcessMidiMessage(status, data1, data2);
                    }
                    break;
                case 0xE0:  // Pitch Bend
                case 0xA0:  // Polyphonic Key Pressure
                case 0xC0:  // Program Change
                case 0xD0:  // Channel Pressure
                    if (ReadByteFromBuffer(&data1)) {
                        ProcessMidiMessage(status, data1, 0);
                    }
                    break;
                case 0xF0:  // System messages
                    ProcessSystemMessage(status);
                    break;
            }
        }
    }
}

void ProcessMidiMessage(u8 status, u8 data1, u8 data2)
{
    // Implement your MIDI message handling logic here
    // This could involve updating synthesizer parameters, triggering notes, etc.
}

void ProcessSystemMessage(u8 status)
{
    // Handle system messages (e.g., timing clock, start, stop, etc.)
}

int main(){
	InitializeBuffer(&midiBuffer);

	if(SetupUart() != XST_SUCCESS){
		return 1;
	}

	SetupUartInterrupts();

	while (1) {
	    ParseUartMessages();
	    // Other main loop operations...
	}

}
